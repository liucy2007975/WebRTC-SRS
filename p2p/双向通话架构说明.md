# 双向通话架构说明

## 核心概念 - SFU模式

ZLMediaKit WebRTC使用SFU（Selective Forwarding Unit）架构，服务器作为媒体转发单元：

### SFU架构
```
用户A:                                    用户B:
┌─────────────┐    ZLMediaKit SFU      ┌─────────────┐
│ 推流A       │───────▶服务器◀─────────│ 推流B       │
│ (发送自己)  │      │转发│            │ (发送自己)  │
├─────────────┤      │    │            ├─────────────┤
│ 拉流B       │◀─────│    │────────────│ 拉流A       │
│ (接收B)     │      │    │            │ (接收A)     │
└─────────────┘      └────┘            └─────────────┘
```

### SFU特点
- **服务器转发**: 所有媒体流通过ZLMediaKit服务器转发
- **选择转发**: 服务器可选择性转发特定流
- **低延迟**: 优化的转发路径
- **可扩展**: 支持多人通话升级
- **TCP友好**: 支持WebRTC over TCP

### 流ID命名规则
- **推流ID**: `{userId}_push_{timestamp}`
- **拉流ID**: 对方的推流ID

## 使用方式

### 1. 用户A（发起方）
```kotlin
val callManager = TrueBidirectionalCallManager(context, factory, eglContext)

// 用户A的推流ID
val userAPushId = "userA_push_${System.currentTimeMillis()}"
// 用户B的推流ID（需要通信交换）
val userBPushId = "userB_push_${System.currentTimeMillis()}"

// 开始通话
lifecycleScope.launch {
    callManager.startBidirectionalCall(
        myPushStreamId = userAPushId,
        peerPushStreamId = userBPushId,
        localVideoSink = localVideoView,
        remoteVideoSink = remoteVideoView
    )
}
```

### 2. 用户B（接收方）
```kotlin
// 用户B的推流ID
val userBPushId = "userB_push_${System.currentTimeMillis()}"
// 用户A的推流ID（需要通信交换）
val userAPushId = "userA_push_${System.currentTimeMillis()}"

// 开始通话
lifecycleScope.launch {
    callManager.startBidirectionalCall(
        myPushStreamId = userBPushId,
        peerPushStreamId = userAPushId,
        localVideoSink = localVideoView,
        remoteVideoSink = remoteVideoView
    )
}
```

## 流ID交换机制

### 方案1: 信令服务器交换
```kotlin
// 1. 用户A生成推流ID
val myPushId = "userA_push_${System.currentTimeMillis()}"

// 2. 通过信令服务器发送给对方
signalingServer.sendOffer(myPushId)

// 3. 接收对方的推流ID
val peerPushId = signalingServer.receiveAnswer()

// 4. 开始通话
callManager.startBidirectionalCall(myPushId, peerPushId, ...)
```

### 方案2: URL参数传递
```kotlin
// 用户A访问: app://call?myPush=userA_push_123&peerPush=userB_push_456
// 用户B访问: app://call?myPush=userB_push_456&peerPush=userA_push_123
```

## ZLMediaKit端点

### 推流端点
```
POST /index/api/webrtc?app=live&stream={myPushStreamId}&type=push&codec=H264/PCMA
```

### 拉流端点
```
POST /index/api/webrtc?app=live&stream={peerPushStreamId}&type=play&codec=H264/PCMA
```

## 完整示例

### 信令交换流程
```kotlin
// 1. 双方通过信令服务器交换推流ID
class SignalingManager {
    suspend fun exchangeStreamIds(): Pair<String, String> {
        val myPushId = "user_${userId}_push_${System.currentTimeMillis()}"
        
        // 发送推流ID给对方
        val peerPushId = sendAndReceive(myPushId)
        
        return Pair(myPushId, peerPushId)
    }
}

// 2. 使用交换的ID建立通话
lifecycleScope.launch {
    val (myPushId, peerPushId) = signalingManager.exchangeStreamIds()
    
    callManager.startBidirectionalCall(
        myPushStreamId = myPushId,
        peerPushStreamId = peerPushId,
        localVideoSink = binding.localVideoView,
        remoteVideoSink = binding.remoteVideoView
    )
}
```

### 简单WebSocket信令示例
```kotlin
// WebSocket信令服务器
class WebSocketSignaling {
    fun onReceiveOffer(offer: OfferMessage) {
        val myPushId = "user_${userId}_push_${System.currentTimeMillis()}"
        
        // 发送应答包含我的推流ID
        sendAnswer(AnswerMessage(myPushId))
        
        // 开始通话
        callManager.startBidirectionalCall(
            myPushStreamId = myPushId,
            peerPushStreamId = offer.pushStreamId,
            localVideoSink = localVideoView,
            remoteVideoSink = remoteVideoView
        )
    }
}
```

## 错误处理

### 常见问题
1. **流ID冲突**: 使用时间戳确保唯一性
2. **网络延迟**: 实现重试机制
3. **权限问题**: 检查摄像头和麦克风权限

### 重试机制
```kotlin
suspend fun establishCallWithRetry(maxRetries: Int = 3) {
    repeat(maxRetries) { attempt ->
        try {
            val (myPushId, peerPushId) = signalingManager.exchangeStreamIds()
            callManager.startBidirectionalCall(myPushId, peerPushId, ...)
            return
        } catch (e: Exception) {
            if (attempt == maxRetries - 1) throw e
            delay(1000 * (attempt + 1))
        }
    }
}
```

## 测试建议

### 本地测试
1. 使用不同的浏览器标签模拟两个用户
2. 使用不同的设备测试
3. 检查流ID是否唯一

### 网络测试
1. 测试不同网络环境（WiFi、4G、5G）
2. 测试网络切换
3. 测试断网重连

### 功能测试
1. 音视频同步
2. 延迟测试
3. 3A处理效果
4. 摄像头切换
5. 静音功能

## 性能优化

### 流ID优化
```kotlin
// 使用UUID确保唯一性
val streamId = "${userId}_${UUID.randomUUID().toString().substring(0, 8)}"

// 添加房间前缀
val roomBasedId = "room_${roomId}_${userId}_push"
```

### 连接优化
- 预生成推流ID
- 并行建立连接
- 心跳检测机制

## 部署检查清单

- [ ] ZLMediaKit服务器已启动并配置正确
- [ ] 防火墙端口已开放（8080）
- [ ] 信令服务器已部署
- [ ] 流ID生成策略已确定
- [ ] 错误处理机制已完善
- [ ] 重试机制已测试

## 监控指标

- 连接建立时间
- 音视频延迟
- 丢包率
- 码率变化
- 设备兼容性

这套架构确保了真正的双向音视频通话，每个用户都有独立的推流和拉流通道。